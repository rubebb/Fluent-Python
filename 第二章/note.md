# 丰富的系列

## 知识点

- 容器序列(list/tuple/collections.deque) / 扁平序列(str/bytes/array.array)
- 容器序列存放的是所包含对象的引用 / 扁平序列在自己的内存空间存储所含的值
- Python 内存对象都有一个包含元数据的标头
- 可变序列继承不可变序列的所有方法
- 内置的具体序列是一种虚拟子类， 使用Sequence / MutableSequence 两个抽象基类来注册
- 生成器表达式 比起 列表推导式 占用更少的内存 因为生成器表达式使用迭代器协议逐个产出项， 而不是构建整个列表提供给其他构造函数
- 元祖比列表占用内存更少
- 元祖本身是不可变的，因为元祖存放引用同一批对象，但是对象为可变对象则可以发生变化
- 永不可变的对象才可哈希
- tuple(t) 直接返回t的引用,list(l)需要创建副本,长度固定,list需要内存空间更富余一些，元祖的引用存储在元祖结构体里的数组，列表需要存储到别处
- match的一大改进是析构。
- 在序列模式中，方括号和圆括号的意思是一样的
- 在 match/ case上下文中, str/bytes/bytearray 实例不作为序列处理，而视为“原子”值
- 模式不解析序列以外的可迭代对象
- 切片和区间排除最后一项是Python风格约定
- ```s[a:b:c]``` 句法指定步距c
- abc表示法只在[]内部有效，得到的结果是一个切片对象slice(a,b,c)
- 省略号是 Ellipsis 对象的别名
- 切片不仅可从序列中提取信息，还可以就地改变可变序列，既不重新构建序列
- 赋值目标是一个切片，则右边必须是一个可迭代对象，即使只有一项
- 序列支持 + 和 *， + 的两个运算对象必须是同一种序列，而且都不可修改，拼接的结果是一个同类型的新序列
- *和+中创建一个新对象
- 不能在列表中多次引用多一个列表
- 目标序列的可变性，会使运算符产生的结果完全不相同
- 不可变序列重复拼接效率低下，因为解释器必须复制整个目标序列，创建一个新序列包含拼接的项，而不是简单追加新项（str除外，被内部优化）
- 不要在元组里放可变对象
- 增量赋值不是原子操作
- 可以通过检查Python字节码，看他背后在干什么
- 就地更改对象的函数或方法应该返回None
- 接受者是方法调用的目标，即方法定义体重绑定到self上的对象
- 返回None有一个缺点：这种方法不能级联调用
- sorted 返回创建的新列表，可以接受任何可迭代对象作为参数，参数key一个只接受一个参数的函数，应用到每一项上，作为排列依据
- memoryview 是一种共享内存的序列类型，可在不复制字节的情况下处理数组
- Numpy 和 SciPy 函数大多使用C 或 C++实现的，可以利用所有的CPU核， 因为它们释放了Python的全局解释锁
- deque对象中部删除项的速度不快。双端队列优化的是在两端的增减项的操作
- append 和 popleft是原子操作，因此你可以放心在多线程应用中把deque作为先进先出队列使用，无须加锁。
- heapq 可把可变序列当做堆队列或优先级队列使用
- Python 序列通常按可变性分类，不过也可以分成扁平序列和容器序列

## 疑点

- abc 库
- 字典推导式
- filter / map
- 笛卡尔积
- PEP
- evaluate
- SyntaxError
- Norvig 的 lis.py
- Python Tutor
- 级联调用
- Numpy
- 全局解释锁
- Desk项目
- 原子操作
- copy.copy
- Multiprocess.JoinableQueue
- 优先级队列
- memoryview
- 并行赋值
- 